<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sixteen pixel dungeon</title>
    <!-- We are loading the Phaser 3 framework from a Content Delivery Network (CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        /* Basic CSS to center the game canvas on the page */
        html, body {
            height: 100%;
            margin: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Menlo, Consolas, Monaco, Adwaita Mono, Liberation Mono, Lucida Console, monospace;
        }
        canvas {
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        a {
            color: wheat;
        }
    </style>
</head>
<body>

    <div style="position: absolute; top: 1px; color: wheat; font-size: 12px;">
        made by <a href="https://willgrant.org" target="_blank" rel="noopener noreferrer">wgx</a> • 
        <a href="https://github.com/wgx/dungeon16px/" target="_blank" rel="noopener noreferrer">code on github</a> •
        <a href="https://ko-fi.com/wllgrnt" target="_blank" rel="noopener noreferrer">buy me a coffee</a> •
        <span class="herenow">1 user here now</span>
    </div>


<script>
// --- GAME CONFIGURATION ---
const TILE_SIZE = 16;
const MAP_WIDTH_TILES = 30;
const MAP_HEIGHT_TILES = 47;
const GAME_WIDTH = MAP_WIDTH_TILES * TILE_SIZE;
const GAME_HEIGHT = MAP_HEIGHT_TILES * TILE_SIZE;

// --- MAP GENERATOR ---
// This class procedurally generates a new map for each level.
class MapGenerator {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }

    // Main generation function
    generate() {
        // 1. Start with a grid full of walls
        const grid = Array.from({ length: this.height }, () => Array(this.width).fill('1'));

        // 2. Carve out floor space using a "Drunkard's Walk" algorithm
        let walkerX = Math.floor(this.width / 2);
        let walkerY = Math.floor(this.height / 2);
        const floorTilesToCarve = (this.width * this.height) * 0.33; // Target 33% floor space
        let floorsCarved = 0;
        let lastDirection = -1; // -1 means no initial direction

        while (floorsCarved < floorTilesToCarve) {
            if (grid[walkerY][walkerX] === '1') {
                grid[walkerY][walkerX] = '0';
                floorsCarved++;
            }
            
            let direction;
            // 60% chance to continue in the same direction
            if (lastDirection !== -1 && Math.random() < 0.6) {
                direction = lastDirection;
            } else {
                direction = Math.floor(Math.random() * 4);
            }

            if (direction === 0 && walkerX > 1) walkerX--;
            else if (direction === 1 && walkerX < this.width - 2) walkerX++;
            else if (direction === 2 && walkerY > 1) walkerY--;
            else if (direction === 3 && walkerY < this.height - 2) walkerY++;
            
            lastDirection = direction; // Remember the last direction for the next step
        }

        // 3. Get a list of all valid floor tile coordinates
        const floorTiles = [];
        for (let y = 0; y < this.height; y++) {
            for (let x = 0; x < this.width; x++) {
                if (grid[y][x] === '0') {
                    floorTiles.push({ x, y });
                }
            }
        }
        
        // --- Place Game Objects ---
        this.placePlayer(grid, floorTiles);
        this.placeExit(grid, floorTiles);
        this.placeItems(grid, floorTiles, 'A', 1, 2); // Place 1-2 artifacts
        this.placeItems(grid, floorTiles, 'S', 2, 5); // Place 2-5 slimes
        this.placeItems(grid, floorTiles, 'B', 1, 4); // Place 1-4 bats
        this.placeItems(grid, floorTiles, '2', 5, 15); // Place 5-15 lava tiles

        return grid;
    }

    // Helper to place objects randomly on floor tiles
    placeItems(grid, floorTiles, type, min, max) {
        const count = Phaser.Math.Between(min, max);
        for (let i = 0; i < count; i++) {
            const randomIndex = Math.floor(Math.random() * floorTiles.length);
            const tile = floorTiles[randomIndex];
            if (grid[tile.y][tile.x] === '0') {
                grid[tile.y][tile.x] = type;
            }
        }
    }
    
    // Place the player, ensuring it's on a floor tile
    placePlayer(grid, floorTiles) {
        const randomIndex = Math.floor(Math.random() * floorTiles.length);
        const tile = floorTiles.splice(randomIndex, 1)[0]; // Remove to avoid placing something else here
        grid[tile.y][tile.x] = 'P';
        this.playerStart = tile;
    }

    // Place the exit, ensuring it's far from the player
    placeExit(grid, floorTiles) {
        let bestTile = null;
        let maxDist = -1;
        for (const tile of floorTiles) {
            const dist = Phaser.Math.Distance.Between(this.playerStart.x, this.playerStart.y, tile.x, tile.y);
            if (dist > maxDist) {
                maxDist = dist;
                bestTile = tile;
            }
        }
        grid[bestTile.y][bestTile.x] = 'E';
    }
}


// --- UTILITY FUNCTIONS ---
const textStyle = { 
    fontFamily: "monospace", 
    fontSize: 12,
    fill: '#ffffff',
    stroke: '#000000',
    strokeThickness: 4
};

// --- PHASER SCENES ---

// 1. StartScene
class StartScene extends Phaser.Scene {
    constructor() { super({ key: 'StartScene' }); }
    create() {
        this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 40, '16 Pixel Dungeon', { ...textStyle, fontSize: '24px' }).setOrigin(0.5);
        this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'Arrow Keys to Move | Space to Attack', textStyle).setOrigin(0.5);
        this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 20, 'Collect 20 artifacts | Monsters drop health', textStyle).setOrigin(0.5);
        const startButton = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 40, 'Click or tap to Start', { ...textStyle, fill: '#00ffff' }).setOrigin(0.5);
        startButton.setInteractive();
        startButton.on('pointerdown', () => {
            // Start the game with default stats
            this.scene.start('GameScene', { hp: 100, artifacts: 0, level: 1 });
        });



    }
}

// 2. GameScene
class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
        this.player = null;
        this.cursors = null;
        this.monsters = null;
        this.artifacts = null;
        this.walls = null;
        this.lava = null;
        this.exits = null;
        this.hpText = null;
        this.artifactText = null;
        this.levelText = null;
        this.lastPlayerDirection = 'down';
    }

    // Receives data from the previous scene (or StartScene)
    init(data) {
        this.playerData = {
            hp: data.hp || 100,
            maxHp: 100,
            artifacts: data.artifacts || 0,
            level: data.level || 1,
            attackPower: 10,
            isAttacking: false,
            isInvincible: false
        };
    }

    preload() {
        const graphics = this.make.graphics({ add: false });

        // Attack Button
        graphics.clear();
        graphics.fillStyle(0xef5350, 0.6);
        graphics.lineStyle(2, 0x000000, 0.8);
        graphics.fillCircle(24, 24, 22);
        graphics.strokeCircle(24, 24, 22);
        graphics.generateTexture('attack_button', 48, 48);

        this.load.image('dpad_arrow', 'assets/dpad.png');
        this.load.image('wall', 'assets/wall.png');
        this.load.image('floor', 'assets/floor.png');
        this.load.image('floor_alt', 'assets/floor_alt.png');
        this.load.image('floor_tree', 'assets/floor_tree.png');
        this.load.image('artifact', 'assets/artifact.png');
        this.load.image('health', 'assets/health.png');
        this.load.image('lava', 'assets/lava.png');
        this.load.image('exit', 'assets/exit.png');
        this.load.image('player', 'assets/player.png');
        this.load.image('slime', 'assets/slime.png');
        this.load.image('bat', 'assets/bat.png');
        this.load.image('attack', 'assets/attack.png');
    }

    create() {
        const mapGenerator = new MapGenerator(MAP_WIDTH_TILES, MAP_HEIGHT_TILES);
        const mapLayout = mapGenerator.generate();

        this.walls = this.physics.add.staticGroup();
        this.lava = this.physics.add.staticGroup();
        this.artifacts = this.physics.add.group();
        this.monsters = this.physics.add.group();
        this.healthPickups = this.physics.add.group();
        this.exits = this.physics.add.staticGroup();

        for (let y = 0; y < mapLayout.length; y++) {
            for (let x = 0; x < mapLayout[y].length; x++) {
                const tileChar = mapLayout[y][x];
                const worldX = x * TILE_SIZE + TILE_SIZE / 2;
                const worldY = y * TILE_SIZE + TILE_SIZE / 2;
                // Place floor tiles everywhere first, choosing randomly between the two types
                
                let floorType;
                const rand = Math.random();
                if (rand < 0.9) {
                    floorType = 'floor'; // 90% chance
                } else if (rand < 0.95) {
                    floorType = 'floor_alt'; // 5% chance
                } else {
                    floorType = 'floor_tree'; // 5% chance
                }

                this.add.image(worldX, worldY, floorType).setDepth(-1);
                
                if (tileChar === '1') { this.walls.create(worldX, worldY, 'wall'); }
                else if (tileChar === '2') { this.lava.create(worldX, worldY, 'lava'); }
                else if (tileChar === 'P') { this.player = this.physics.add.sprite(worldX, worldY, 'player'); }
                else if (tileChar === 'A') { this.artifacts.add(this.physics.add.sprite(worldX, worldY, 'artifact')); }
                else if (tileChar === 'S') { this.createMonster(worldX, worldY, 'slime', 30, 20, 20 + this.playerData.level); }
                else if (tileChar === 'B') { this.createMonster(worldX, worldY, 'bat', 20, 40, 10 + this.playerData.level); }
                else if (tileChar === 'E') { this.exits.create(worldX, worldY, 'exit'); }
            }
        }


            // Initialize touch control state object
            this.touchControls = { up: false, down: false, left: false, right: false, attack: false };

            // Only create touch controls on non-desktop devices
            if (!this.sys.game.device.os.desktop) {
                const dpadX = 100;
                const dpadY = GAME_HEIGHT - 110;
                const attackButtonX = GAME_WIDTH - 60;
                const attackButtonY = GAME_HEIGHT - 60;

                // Create D-Pad buttons
                const up = this.add.sprite(dpadX, dpadY - 40, 'dpad_arrow').setScrollFactor(0).setInteractive().setAlpha(0.8);
                const down = this.add.sprite(dpadX, dpadY + 40, 'dpad_arrow').setRotation(Math.PI).setScrollFactor(0).setInteractive().setAlpha(0.8);
                const left = this.add.sprite(dpadX - 40, dpadY, 'dpad_arrow').setRotation(-Math.PI / 2).setScrollFactor(0).setInteractive().setAlpha(0.8);
                const right = this.add.sprite(dpadX + 40, dpadY, 'dpad_arrow').setRotation(Math.PI / 2).setScrollFactor(0).setInteractive().setAlpha(0.8);

                // Create Attack button
                const attack = this.add.sprite(attackButtonX, attackButtonY, 'attack_button').setScrollFactor(0).setInteractive().setAlpha(0.8);

                // D-Pad Pointer Events
                const setDir = (btn, dir, state) => {
                    btn.on(state, () => { this.touchControls[dir] = (state === 'pointerdown'); });
                };
                ['pointerdown', 'pointerup', 'pointerout'].forEach(state => {
                    setDir(up, 'up', state);
                    setDir(down, 'down', state);
                    setDir(left, 'left', state);
                    setDir(right, 'right', state);
                });

                // Attack Button Pointer Events
                attack.on('pointerdown', () => { this.touchControls.attack = true; });
                // Note: We don't need pointerup for attack, as we'll reset the flag after one use.
            }



        if (!this.player) { console.error("Player failed to spawn!"); return; }

        this.player.setCollideWorldBounds(true);
        this.player.body.setSize(12, 12);

        // --- MOVEMENT PHYSICS SETUP ---
        // Set a max velocity and drag to create smooth acceleration and deceleration
        this.player.body.setMaxVelocity(120); // The maximum speed the player can reach
        this.player.body.setDrag(800); // The rate of deceleration (higher means faster stopping)

        this.cursors = this.input.keyboard.createCursorKeys();
        this.spaceBar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.monsters, this.walls);
        this.physics.add.collider(this.monsters, this.monsters);
        this.physics.add.overlap(this.player, this.artifacts, this.collectArtifact, null, this);
        this.physics.add.overlap(this.player, this.healthPickups, this.collectHealth, null, this);
        this.physics.add.overlap(this.player, this.monsters, this.playerHit, null, this);
        this.physics.add.overlap(this.player, this.lava, this.onLava, null, this);
        this.physics.add.overlap(this.player, this.exits, this.goToNextLevel, null, this);
        
        this.cameras.main.startFollow(this.player, true, 0.5, 0.5);
        this.cameras.main.setBounds(0, 0, GAME_WIDTH, GAME_HEIGHT);

        this.hpText = this.add.text(10, 10, '', textStyle).setScrollFactor(0);
        this.artifactText = this.add.text(10, 25, '', textStyle).setScrollFactor(0);
        this.levelText = this.add.text(10, 40, '', textStyle).setScrollFactor(0);
        this.updateHUD();
    }

    update() {
        if (!this.player || !this.player.active) return;
        this.handlePlayerMovement();
        this.handlePlayerAttack();
        this.updateMonsters();
        if (this.playerData.hp <= 0) { this.scene.start('GameOverScene'); }
        if (this.playerData.artifacts >= 20) { this.scene.start('WinScene'); }
    }

    goToNextLevel(player, exit) {
        this.scene.start('GameScene', {
            hp: this.playerData.hp,
            artifacts: this.playerData.artifacts,
            level: this.playerData.level + 1
        });
    }

    createMonster(x, y, key, hp, speed, damage) {
        const monster = this.physics.add.sprite(x, y, key);
        monster.setData({ hp: hp, speed: speed, damage: damage, moveTimer: 0 });
        monster.setCollideWorldBounds(true);
        monster.body.setSize(12, 12);
        this.monsters.add(monster);
    }

    handlePlayerMovement() {
        // --- NEW MOVEMENT LOGIC ---
        // We now set acceleration instead of velocity. Drag will handle the stopping.
        const acceleration = 800; // The rate of acceleration
        this.player.setAcceleration(0);

        if (this.cursors.left.isDown || this.touchControls.left) {
            this.player.setAccelerationX(-acceleration);
            this.lastPlayerDirection = 'left';
        } else if (this.cursors.right.isDown || this.touchControls.right) {
            this.player.setAccelerationX(acceleration);
            this.lastPlayerDirection = 'right';
        }

        if (this.cursors.up.isDown || this.touchControls.up) {
            this.player.setAccelerationY(-acceleration);
            this.lastPlayerDirection = 'up';
        } else if (this.cursors.down.isDown || this.touchControls.down) {
            this.player.setAccelerationY(acceleration);
            this.lastPlayerDirection = 'down';
        }
    }

    handlePlayerAttack() {

        if ((Phaser.Input.Keyboard.JustDown(this.spaceBar) || this.touchControls.attack) && !this.playerData.isAttacking) {
            this.playerData.isAttacking = true;
            const attackHitbox = this.add.sprite(this.player.x, this.player.y, 'attack').setAlpha(0.9);
            this.physics.world.enable(attackHitbox);
            attackHitbox.body.setSize(24, 24);
            switch(this.lastPlayerDirection) {
                case 'up': attackHitbox.setPosition(this.player.x, this.player.y - 16); break;
                case 'down': attackHitbox.setPosition(this.player.x, this.player.y + 16); break;
                case 'left': attackHitbox.setPosition(this.player.x - 16, this.player.y); break;
                case 'right': attackHitbox.setPosition(this.player.x + 16, this.player.y); break;
            }
            this.physics.add.overlap(attackHitbox, this.monsters, (box, monster) => { this.damageMonster(monster, this.playerData.attackPower); }, null, this);
            this.time.delayedCall(150, () => { attackHitbox.destroy(); this.playerData.isAttacking = false; });
            this.touchControls.attack = false; 
        }
    }
    
    updateMonsters() {
        this.monsters.getChildren().forEach(monster => {
            if (!monster.active) return;
            const distanceToPlayer = Phaser.Math.Distance.Between(monster.x, monster.y, this.player.x, this.player.y);
            const speed = monster.getData('speed');
            if (distanceToPlayer < 100) { this.physics.moveToObject(monster, this.player, speed); }
            else if (this.time.now > monster.getData('moveTimer')) {
                monster.setData('moveTimer', this.time.now + 2000);
                monster.setVelocity(Phaser.Math.Between(-speed, speed), Phaser.Math.Between(-speed, speed));
            }
        });
    }

    damageMonster(monster, amount) {
        let hp = monster.getData('hp') - amount;
        monster.setData('hp', hp);
        monster.setTint(0xff0000);
        if (hp <= 0) {
            if (Phaser.Math.Between(1, 4) === 1) { this.healthPickups.add(this.physics.add.sprite(monster.x, monster.y, 'health')); }
            monster.destroy();
        } else { this.time.delayedCall(100, () => monster.clearTint()); }
    }

    playerHit(player, monster) {
        if (this.playerData.isInvincible) return;
        const damage = monster.getData('damage');
        this.playerData.hp -= damage;
        this.updateHUD();
        const knockback = new Phaser.Math.Vector2(player.x - monster.x, player.y - monster.y).normalize().scale(150);
        player.setVelocity(knockback.x, knockback.y);
        this.playerData.isInvincible = true;
        this.player.setAlpha(0.5);
        this.time.delayedCall(1000, () => { if (this.player.active) { this.playerData.isInvincible = false; this.player.setAlpha(1); } });
    }

    onLava(player, lavaTile) {
        if (this.playerData.isInvincible) return;
        this.playerData.hp -= 5;
        this.updateHUD();
        this.playerData.isInvincible = true;
        this.player.setTint(0xff8c00);
        this.time.delayedCall(500, () => { if (this.player.active) { this.playerData.isInvincible = false; this.player.clearTint(); } });
    }

    collectArtifact(player, artifact) {
        artifact.destroy();
        this.playerData.artifacts++;
        this.updateHUD();
    }
    
    collectHealth(player, healthPickup) {
        healthPickup.destroy();
        this.playerData.hp = Math.min(this.playerData.maxHp, this.playerData.hp + 20);
        this.updateHUD();
    }

    updateHUD() {
        this.hpText.setText(`HP: ${this.playerData.hp} / ${this.playerData.maxHp}`).setAlpha(0.5);
        this.artifactText.setText(`Artifacts: ${this.playerData.artifacts} / 20`).setAlpha(0.5);
        this.levelText.setText(`Dungeon Level: ${this.playerData.level}`).setAlpha(0.5);
    }
}

// 3. GameOverScene
class GameOverScene extends Phaser.Scene {
    constructor() { super({ key: 'GameOverScene' }); }
    create() {
        this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20, 'Game Over', { ...textStyle, fontSize: '32px' }).setOrigin(0.5);
        const restartButton = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 20, 'Click to Restart', { ...textStyle, fill: '#ffff00' }).setOrigin(0.5);
        restartButton.setInteractive();
        restartButton.on('pointerdown', () => { this.scene.start('GameScene'); });
    }
}

// 4. WinScene
class WinScene extends Phaser.Scene {
    constructor() { super({ key: 'WinScene' }); }
    create() {
        this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20, 'You Win!', { ...textStyle, fontSize: '32px', fill: '#00ff00' }).setOrigin(0.5);
        const playAgainButton = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 20, 'Click to Play Again', { ...textStyle, fill: '#00ff00' }).setOrigin(0.5);
        playAgainButton.setInteractive();
        playAgainButton.on('pointerdown', () => { this.scene.start('GameScene'); });
    }
}

// --- PHASER GAME CONFIGURATION ---
const config = {
    type: Phaser.AUTO,
    width: GAME_WIDTH,
    height: GAME_HEIGHT,
    pixelArt: true,
    physics: {
        default: 'arcade',
        arcade: { debug: false }
    },
    scene: [StartScene, GameScene, GameOverScene, WinScene]
};

const game = new Phaser.Game(config);

</script>


<script src="https://wgx.github.io/herenow/herenow.min.js" defer></script>

</body>
</html>
